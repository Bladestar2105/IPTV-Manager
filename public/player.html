<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IPTV Web Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="vendor/bootstrap.min.css" rel="stylesheet">
  <link href="style.css" rel="stylesheet">
  <style>
    body { padding: 0; margin: 0; overflow: hidden; background: #111; color: #eee; height: 100vh; display: flex; flex-direction: column; }
    #player-container {
      background: #000;
      width: 100%;
      height: 60vh;
      position: relative;
      flex-shrink: 0;
    }
    video { width: 100%; height: 100%; }

    #controls-bar {
      height: 50px;
      background: #111;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 1rem;
      flex-shrink: 0;
    }

    /* Timeline Layout */
    #timeline-view {
      flex-grow: 1;
      display: flex;
      overflow: hidden;
      position: relative;
      background: #1a1a1a;
    }

    /* List Layout (VOD) */
    #list-view {
      flex-grow: 1;
      overflow-y: auto;
      background: #111;
      display: none;
    }

    #channel-sidebar {
      width: 250px;
      flex-shrink: 0;
      overflow: hidden; /* Scroll synced via JS */
      border-right: 1px solid #333;
      background: #0a0a0a;
      margin-top: 30px; /* Offset for header */
    }

    #epg-grid {
      flex-grow: 1;
      overflow: auto;
      position: relative;
    }

    #time-header {
      height: 30px;
      background: #222;
      position: sticky;
      top: 0;
      z-index: 20;
      border-bottom: 1px solid #444;
      white-space: nowrap;
      overflow: hidden;
    }

    .time-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #444;
      font-size: 10px;
      padding-left: 2px;
      color: #aaa;
    }

    .channel-row {
      height: 50px;
      display: flex;
      align-items: center;
      padding: 0 10px;
      border-bottom: 1px solid #222;
      cursor: pointer;
      background: #0a0a0a;
      transition: background 0.2s;
    }
    .channel-row:hover, .channel-row.active {
      background: #222;
    }
    .channel-row img {
      width: 30px;
      height: 30px;
      object-fit: contain;
      margin-right: 10px;
    }
    .channel-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: bold;
      font-size: 0.9rem;
    }

    .epg-row {
      height: 50px;
      position: relative;
      border-bottom: 1px solid #2a2a2a;
      background: #1a1a1a;
    }

    .program-bar {
      position: absolute;
      top: 4px;
      bottom: 4px;
      background: #333;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .program-bar:hover {
      background: #444;
      color: #fff;
      border-color: #666;
      z-index: 10;
    }
    .program-bar.current {
      background: #1e3a8a;
      border-color: #3b82f6;
    }
    .program-title { font-weight: bold; margin-left: 5px; }
    .program-time { font-size: 10px; color: #999; flex-shrink: 0; }

    .current-time-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(255, 0, 0, 0.6);
      z-index: 15;
      pointer-events: none;
    }

    /* List View Items */
    .vod-item {
        cursor: pointer;
        transition: background 0.2s;
        border-color: #333 !important;
    }
    .vod-item:hover { background: #222 !important; }
    .vod-item.active { background: #1e3a8a !important; color: #fff; }

    /* Loading Overlay */
    #loading-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #fff;
    }

    @media (max-width: 768px) {
      #channel-sidebar {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        z-index: 100;
        width: 80%;
        max-width: 300px;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        background: #0a0a0a;
        margin-top: 0;
        border-right: 1px solid #333;
      }
      #channel-sidebar.open {
        transform: translateX(0);
        box-shadow: 2px 0 10px rgba(0,0,0,0.5);
      }
      #controls-bar {
        height: auto;
        flex-wrap: wrap;
        padding: 0.5rem;
      }
      #controls-bar > * {
        margin-bottom: 0.5rem;
      }
      #category-select {
        width: 100% !important;
        order: 3;
      }
      #search-input {
        width: 100% !important;
        order: 4;
      }
      #clock {
        display: none;
      }
      #player-container {
        height: auto;
        aspect-ratio: 16/9;
      }
    }
  </style>
</head>
<body>

<div id="player-container">
  <video id="video" controls autoplay playsinline webkit-playsinline></video>
</div>

<div id="controls-bar">
  <button id="sidebar-toggle" class="btn btn-sm btn-outline-secondary me-2 d-md-none">â˜°</button>
  <div class="form-check form-switch me-3">
    <input class="form-check-input" type="checkbox" id="transcode-switch">
    <label class="form-check-label text-light" for="transcode-switch" data-i18n="transcodeAudio">Fix Audio</label>
  </div>

  <ul class="nav nav-pills me-3" id="player-tabs">
      <li class="nav-item"><a class="nav-link active py-1" href="#" data-type="live" data-i18n="liveTV">Live TV</a></li>
      <li class="nav-item"><a class="nav-link py-1" href="#" data-type="movie" data-i18n="movies">Movies</a></li>
  </ul>

  <select id="category-select" class="form-select form-select-sm bg-dark text-light border-secondary me-2" style="width: 180px;">
     <option value="" data-i18n="allCategories">All Categories</option>
  </select>

  <input type="text" id="search-input" class="form-control form-control-sm bg-dark text-light border-secondary me-2" style="width: 150px;" placeholder="Search..." data-i18n-placeholder="searchPlaceholder">

  <div class="ms-auto text-muted small" id="clock">00:00</div>
</div>

<div id="timeline-view">
  <div id="channel-sidebar"></div>
  <div id="epg-grid">
    <div id="time-header"></div>
    <div id="epg-rows"></div>
    <div id="current-time-indicator" class="current-time-line"></div>
  </div>
  <div id="loading-overlay" style="display: none;">Loading EPG...</div>
</div>

<div id="list-view" class="list-group list-group-flush"></div>

<script src="vendor/bootstrap.bundle.min.js"></script>
<script src="vendor/hls.min.js"></script>
<script src="vendor/mpegts.min.js"></script>
<script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
<script src="i18n.js"></script>
<script>
  const urlParams = new URLSearchParams(window.location.search);
  const token = urlParams.get('token');
  const username = urlParams.get('username');
  const password = urlParams.get('password');

  if (!token && (!username || !password)) {
    document.body.innerHTML = `<div class="alert alert-danger m-4">${t('missingCredentials')}</div>`;
    throw new Error('Missing credentials');
  }

  let currentType = 'live';
  let allChannels = [];
  let currentChannels = [];
  let epgSchedule = {}; // channel_id -> [programs]
  let hls = null;
  let flvPlayer = null;
  let dashPlayer = null;
  const video = document.getElementById('video');

  // Timeline Config
  const PIXELS_PER_MINUTE = 4; // 240px per hour
  const ROW_HEIGHT = 50;
  let timelineStart = Math.floor(Date.now() / 1000) - 3600; // Start 1 hour ago
  timelineStart = timelineStart - (timelineStart % 3600); // Round to hour

  // DOM Elements
  const catSelect = document.getElementById('category-select');
  const searchInput = document.getElementById('search-input');
  const sidebarEl = document.getElementById('channel-sidebar');
  const epgGridEl = document.getElementById('epg-grid');
  const epgRowsEl = document.getElementById('epg-rows');
  const timeHeaderEl = document.getElementById('time-header');
  const loadingEl = document.getElementById('loading-overlay');
  const currentTimeIndicator = document.getElementById('current-time-indicator');
  const timelineView = document.getElementById('timeline-view');
  const listView = document.getElementById('list-view');

  function translatePage() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.getAttribute('data-i18n');
      el.textContent = t(key);
    });
    document.title = t('playerTitle');
  }
  translatePage();

  // Clock
  setInterval(() => {
    document.getElementById('clock').textContent = new Date().toLocaleTimeString();
    if (currentType === 'live') updateCurrentTimeLine();
  }, 60000);

  function getAuthParams() {
      if (token) return `token=${encodeURIComponent(token)}`;
      return `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`;
  }

  async function init() {
      loadingEl.style.display = 'flex';

      try {
          // 1. Fetch Playlist
          const res = await fetch(`/api/player/playlist?${getAuthParams()}`);
          if (!res.ok) throw new Error('Playlist Fetch Error');
          const text = await res.text();
          allChannels = parseM3U(text);
          console.log(`Loaded ${allChannels.length} channels`);

          // 2. Fetch EPG Schedule (Now - 2h to Now + 12h)
          const start = Math.floor(Date.now() / 1000) - 7200;
          const end = start + (14 * 3600);
          const epgRes = await fetch(`/api/epg/schedule?start=${start}&end=${end}&${getAuthParams()}`);
          if (epgRes.ok) {
              epgSchedule = await epgRes.json();
          }

          updateCategories();
          renderView();

          // Scroll to current time (center it roughly) if live
          if (currentType === 'live') {
              const now = Math.floor(Date.now() / 1000);
              const offset = (now - timelineStart) / 60 * PIXELS_PER_MINUTE;
              epgGridEl.scrollLeft = Math.max(0, offset - (epgGridEl.clientWidth / 2));

              epgGridEl.addEventListener('scroll', () => {
                  sidebarEl.scrollTop = epgGridEl.scrollTop;
              });
              updateCurrentTimeLine();
          }

      } catch (e) {
          console.error(e);
          alert('Error loading data: ' + e.message);
      } finally {
          loadingEl.style.display = 'none';
      }
  }

  function parseM3U(content) {
      const lines = content.split('\n');
      const result = [];
      let currentItem = {};

      for (let line of lines) {
          line = line.trim();
          if (!line) continue;

          if (line.startsWith('#EXTINF:')) {
              const info = line.substring(8);
              const commaIndex = info.lastIndexOf(',');
              let attrs = '';
              let title = '';

              if (commaIndex !== -1) {
                  attrs = info.substring(0, commaIndex);
                  title = info.substring(commaIndex + 1).trim();
              } else {
                  attrs = info;
              }

              currentItem = { name: title, group: 'Uncategorized', logo: '' };

              const matches = attrs.match(/([a-zA-Z0-9-]+)="([^"]*)"/g);
              if (matches) {
                  matches.forEach(m => {
                      const [key, val] = m.split('=');
                      const cleanVal = val.replace(/"/g, '');
                      if (key === 'group-title') currentItem.group = cleanVal;
                      if (key === 'tvg-logo') currentItem.logo = cleanVal;
                      if (key === 'tvg-id') currentItem.epg_id = cleanVal;
                      if (key === 'plot') currentItem.plot = cleanVal;
                  });
              }
          } else if (line.startsWith('#KODIPROP:')) {
              const prop = line.substring(10).trim();
              const parts = prop.split('=');
              const key = parts[0];
              const val = parts.slice(1).join('=');

              if (!currentItem.drm) currentItem.drm = {};
              if (key === 'inputstream.adaptive.license_type') currentItem.drm.license_type = val;
              if (key === 'inputstream.adaptive.license_key') currentItem.drm.license_key = val;
          } else if (!line.startsWith('#')) {
              if (currentItem.name) {
                  currentItem.url = line;
                  if (line.includes('/movie/')) currentItem.type = 'movie';
                  else if (line.includes('/series/')) currentItem.type = 'series';
                  else currentItem.type = 'live';

                  result.push(currentItem);
                  currentItem = {};
              }
          }
      }
      return result;
  }

  function updateCategories() {
      const groups = new Set();
      allChannels.forEach(c => {
          if (c.type === currentType && c.group) groups.add(c.group);
      });
      const categories = Array.from(groups).sort();

      catSelect.innerHTML = `<option value="">${t('allCategories')}</option>`;
      categories.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          catSelect.appendChild(opt);
      });
  }

  function renderView() {
      if (currentType === 'live') {
          timelineView.style.display = 'flex';
          listView.style.display = 'none';
          renderTimeline();
      } else {
          timelineView.style.display = 'none';
          listView.style.display = 'block';
          renderList();
      }
  }

  function renderList() {
      const catId = catSelect.value;
      const search = searchInput.value.toLowerCase();

      const filtered = allChannels.filter(s => {
          if (s.type !== currentType) return false;
          const matchesCat = !catId || s.group === catId;
          const matchesSearch = !search || s.name.toLowerCase().includes(search);
          return matchesCat && matchesSearch;
      });

      listView.innerHTML = '';
      const toRender = filtered.slice(0, 100);

      if (toRender.length === 0) {
          listView.innerHTML = `<div class="text-muted p-3">${t('noResults', {search: search})}</div>`;
          return;
      }

      toRender.forEach(s => {
          const a = document.createElement('a');
          a.className = 'list-group-item list-group-item-action vod-item bg-dark text-light';

          const div = document.createElement('div');
          div.className = 'd-flex align-items-center';

          if (s.logo) {
              const img = document.createElement('img');
              img.src = s.logo;
              img.className = 'channel-icon';
              img.style.width = '40px';
              img.style.marginRight = '10px';
              img.onerror = () => img.style.display = 'none';
              div.appendChild(img);
          }

          const info = document.createElement('div');
          info.style.overflow = 'hidden';

          const name = document.createElement('div');
          name.className = 'fw-bold text-truncate';
          name.textContent = s.name;
          info.appendChild(name);

          if (s.plot) {
              const plot = document.createElement('div');
              plot.className = 'small text-muted text-truncate';
              plot.textContent = s.plot;
              info.appendChild(plot);
          }

          div.appendChild(info);
          a.appendChild(div);

          a.onclick = () => {
              document.querySelectorAll('.vod-item').forEach(el => el.classList.remove('active'));
              a.classList.add('active');
              playStream(s);
          };

          listView.appendChild(a);
      });
  }

  function renderTimeline() {
      const catId = catSelect.value;
      const search = searchInput.value.toLowerCase();

      currentChannels = allChannels.filter(s => {
          if (s.type !== 'live') return false;
          const matchesCat = !catId || s.group === catId;
          const matchesSearch = !search || s.name.toLowerCase().includes(search);
          return matchesCat && matchesSearch;
      });

      sidebarEl.innerHTML = '';
      epgRowsEl.innerHTML = '';
      timeHeaderEl.innerHTML = '';

      const headerWidth = 24 * 60 * PIXELS_PER_MINUTE; // 24h width
      timeHeaderEl.style.width = headerWidth + 'px';

      for (let i = 0; i < 24; i++) {
          const t = timelineStart + (i * 3600);
          const date = new Date(t * 1000);
          const marker = document.createElement('div');
          marker.className = 'time-marker';
          marker.style.left = (i * 60 * PIXELS_PER_MINUTE) + 'px';
          marker.textContent = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          timeHeaderEl.appendChild(marker);
      }

      const fragmentSidebar = document.createDocumentFragment();
      const fragmentRows = document.createDocumentFragment();
      const renderLimit = 200;
      const channelsToRender = currentChannels.slice(0, renderLimit);

      channelsToRender.forEach(ch => {
          // Sidebar Item
          const rowDiv = document.createElement('div');
          rowDiv.className = 'channel-row';
          if (ch.logo) {
              const img = document.createElement('img');
              img.src = ch.logo;
              img.onerror = () => img.style.display = 'none';
              rowDiv.appendChild(img);
          }
          const nameSpan = document.createElement('div');
          nameSpan.className = 'channel-name';
          nameSpan.textContent = ch.name;
          rowDiv.appendChild(nameSpan);

          rowDiv.onclick = () => {
              document.querySelectorAll('.channel-row').forEach(el => el.classList.remove('active'));
              rowDiv.classList.add('active');
              playStream(ch);
              if (window.innerWidth <= 768) sidebarEl.classList.remove('open');
          };

          fragmentSidebar.appendChild(rowDiv);

          // EPG Row
          const epgRow = document.createElement('div');
          epgRow.className = 'epg-row';
          epgRow.style.width = headerWidth + 'px';

          const programs = epgSchedule[ch.epg_id] || [];
          programs.forEach(prog => {
              const startOffset = Math.max(0, prog.start - timelineStart);
              const duration = prog.stop - prog.start;

              if (startOffset + duration < 0) return;

              const left = (startOffset / 60) * PIXELS_PER_MINUTE;
              const width = (duration / 60) * PIXELS_PER_MINUTE;

              const bar = document.createElement('div');
              bar.className = 'program-bar';
              const now = Math.floor(Date.now() / 1000);
              if (prog.start <= now && prog.stop >= now) bar.classList.add('current');

              bar.style.left = left + 'px';
              bar.style.width = Math.max(1, width - 2) + 'px'; // -2 for margin

              const timeStr = new Date(prog.start * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

              // Safe DOM construction (XSS Fix)
              const timeSpan = document.createElement('span');
              timeSpan.className = 'program-time';
              timeSpan.textContent = timeStr;

              const titleSpan = document.createElement('span');
              titleSpan.className = 'program-title';
              titleSpan.textContent = prog.title;

              bar.appendChild(timeSpan);
              bar.appendChild(titleSpan);

              bar.title = `${prog.title}\n${new Date(prog.start * 1000).toLocaleString()} - ${new Date(prog.stop * 1000).toLocaleString()}\n${prog.desc}`;

              epgRow.appendChild(bar);
          });

          fragmentRows.appendChild(epgRow);
      });

      sidebarEl.appendChild(fragmentSidebar);
      epgRowsEl.appendChild(fragmentRows);

      // Reset height to allow shrinking if fewer channels
      currentTimeIndicator.style.height = '';
  }

  function updateCurrentTimeLine() {
      const now = Math.floor(Date.now() / 1000);
      const offset = now - timelineStart;
      if (offset >= 0) {
          const left = (offset / 60) * PIXELS_PER_MINUTE;
          currentTimeIndicator.style.left = left + 'px';
          // Calculate height from content, not container scrollHeight (which might be stale)
          const contentHeight = Math.max(epgRowsEl.offsetHeight + timeHeaderEl.offsetHeight, epgGridEl.scrollHeight);
          currentTimeIndicator.style.height = contentHeight + 'px';
      }
  }

  // Player Logic
  const transcodeSwitch = document.getElementById('transcode-switch');
  const savedTranscode = localStorage.getItem('transcode_enabled') === 'true';
  transcodeSwitch.checked = savedTranscode;

  transcodeSwitch.addEventListener('change', () => {
      localStorage.setItem('transcode_enabled', transcodeSwitch.checked);
      let currentUrl = video.dataset.currentUrl;
      if (currentUrl) {
          if (transcodeSwitch.checked) {
              if (!currentUrl.includes('transcode=true')) {
                  const separator = currentUrl.includes('?') ? '&' : '?';
                  currentUrl += `${separator}transcode=true`;
              }
          } else {
              currentUrl = currentUrl.replace(/[?&]transcode=true/, '');
          }
          initPlayer(currentUrl, currentType);
      }
  });

  function playStream(stream) {
      let url = stream.url;
      if (token && !url.includes('token=')) {
          const separator = url.includes('?') ? '&' : '?';
          url += `${separator}token=${encodeURIComponent(token)}`;
      }
      if (transcodeSwitch.checked && url.includes('.ts')) {
          const separator = url.includes('?') ? '&' : '?';
          url += `${separator}transcode=true`;
      }

      video.dataset.currentUrl = url;

      // Store DRM info
      if (stream.drm) {
          video.dataset.drm = JSON.stringify(stream.drm);
      } else {
          delete video.dataset.drm;
      }

      initPlayer(url, stream.type || 'live');
  }

  function initPlayer(url, type) {
    // iOS/Safari Fix: Force HLS if MPEGTS is not supported but Native HLS is
    if (url.includes('.ts') && (!mpegts.isSupported() || /iPad|iPhone|iPod/.test(navigator.userAgent)) && video.canPlayType('application/vnd.apple.mpegurl')) {
        console.log('Detected iOS/Safari: Switching to HLS (.m3u8)');
        url = url.replace(/\.ts($|\?)/, '.m3u8$1');
    }

    if (flvPlayer) {
        if (flvPlayer._mediaElement) flvPlayer.detachMediaElement();
        flvPlayer.destroy();
        flvPlayer = null;
    }
    if (hls) {
        hls.destroy();
        hls = null;
    }
    if (dashPlayer) {
        dashPlayer.destroy();
        dashPlayer = null;
    }

    if (url.includes('.mpd') && typeof dashjs !== 'undefined') {
        dashPlayer = dashjs.MediaPlayer().create();
        dashPlayer.initialize(video, url, true);

        // DRM Configuration
        if (video.dataset.drm) {
            try {
                const drm = JSON.parse(video.dataset.drm);
                const protData = {};

                if (drm.license_type && drm.license_key) {
                    let keySystem = drm.license_type;
                    // Map common aliases
                    if (keySystem === 'clearkey') keySystem = 'org.w3.clearkey';
                    if (keySystem === 'widevine') keySystem = 'com.widevine.alpha';
                    if (keySystem === 'playready') keySystem = 'com.microsoft.playready';

                    let licenseUrl = drm.license_key;
                    const headers = {};

                    if (licenseUrl.includes('|')) {
                        const parts = licenseUrl.split('|');
                        licenseUrl = parts[0];
                        for (let i = 1; i < parts.length; i++) {
                            const [hKey, hVal] = parts[i].split('=');
                            if (hKey && hVal) headers[hKey] = hVal;
                        }
                    }

                    if (keySystem === 'org.w3.clearkey' && !licenseUrl.startsWith('http')) {
                         // ClearKey specific (kid:key)
                         // This is a naive parser for kid:key format
                         // DashJS expects { "kid": "key" } in clearkeys object
                         const parts = licenseUrl.split(':');
                         if (parts.length === 2) {
                             protData[keySystem] = {
                                 clearkeys: {
                                     [parts[0]]: parts[1]
                                 }
                             };
                         }
                    } else {
                        protData[keySystem] = {
                            serverURL: licenseUrl,
                            httpRequestHeaders: headers
                        };
                    }

                    dashPlayer.setProtectionData(protData);
                }
            } catch(e) {
                console.error('DRM Setup Error:', e);
            }
        }

    } else if (url.includes('.ts') && mpegts.isSupported()) {
        const isLive = (type === 'live');
        flvPlayer = mpegts.createPlayer({
            type: 'mpegts',
            url: url,
            isLive: isLive,
            cors: true
        });
        flvPlayer.attachMediaElement(video);
        flvPlayer.load();

        // Error Handling Logic (Restored)
        flvPlayer.on(mpegts.Events.ERROR, (errorType, errorDetail, errorInfo) => {
            console.warn('Mpegts Error:', errorType, errorDetail, errorInfo);
            if (errorType === mpegts.ErrorTypes.MEDIA_ERROR) {
                const transcodeSwitch = document.getElementById('transcode-switch');
                if (transcodeSwitch && !transcodeSwitch.checked) {
                    console.log('Playback error detected. Auto-fixing...');
                    const toast = document.createElement('div');
                    toast.className = 'alert alert-info position-absolute top-0 start-0 m-3';
                    toast.style.zIndex = '1002';
                    toast.textContent = t('autoFixingAudio') || 'Playback Error. Enabling audio fix...';
                    document.getElementById('player-container').appendChild(toast);
                    setTimeout(() => toast.remove(), 3000);

                    transcodeSwitch.checked = true;
                    localStorage.setItem('transcode_enabled', 'true');

                    setTimeout(() => {
                        let currentUrl = video.dataset.currentUrl;
                        if (currentUrl) {
                             if (!currentUrl.includes('transcode=')) {
                                const separator = currentUrl.includes('?') ? '&' : '?';
                                currentUrl += `${separator}transcode=true`;
                             }
                             initPlayer(currentUrl, type);
                        }
                    }, 1000);
                } else {
                    const toast = document.createElement('div');
                    toast.className = 'alert alert-warning position-absolute top-0 start-0 m-3';
                    toast.textContent = t('playbackError') || 'Playback Error';
                    document.getElementById('player-container').appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                }
            }
        });

        flvPlayer.play().catch(e => console.error(e));
    } else if (Hls.isSupported() && url.includes('.m3u8')) {
      hls = new Hls();
      hls.loadSource(url);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, function() {
        video.play();
      });
    } else {
      video.src = url;
      video.load();
      video.play().catch(e => console.log('Autoplay blocked:', e));
    }
  }

  // Event Listeners
  document.querySelectorAll('#player-tabs .nav-link').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      document.querySelectorAll('#player-tabs .nav-link').forEach(l => l.classList.remove('active'));
      e.target.classList.add('active');
      currentType = e.target.dataset.type;

      catSelect.value = '';
      searchInput.value = '';

      updateCategories();
      renderView();
    });
  });

  catSelect.addEventListener('change', () => {
      if (currentType === 'live') renderTimeline();
      else renderList();
  });

  searchInput.addEventListener('input', debounce(() => {
      if (currentType === 'live') renderTimeline();
      else renderList();
  }, 500));

  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Sidebar Toggle
  const sidebarToggle = document.getElementById('sidebar-toggle');
  if (sidebarToggle) {
      sidebarToggle.addEventListener('click', () => {
          sidebarEl.classList.toggle('open');
      });
  }

  init();
</script>
</body>
</html>
